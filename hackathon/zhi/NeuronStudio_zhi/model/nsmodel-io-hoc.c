#include "nsmodel-io-hoc.h"


NS_PRIVATE NsError _ns_hoc_write_header( NsFile *file )
   {
   NS_PRIVATE const nschar *____ns_hoc_header =
      "*/" NS_STRING_NEWLINE
      NS_STRING_NEWLINE
      ;

   return ns_file_print(
            file,
            "/*" NS_STRING_NEWLINE
            "Generated by NeuronStudio " NS_FMT_INT "." NS_FMT_INT "." NS_FMT_INT " on " NS_FMT_STRING
            NS_FMT_STRING,
            NS_VERSION_MAJOR,
            NS_VERSION_MINOR,
            NS_VERSION_MICRO,
            _ns_ctime_ex(),
            ____ns_hoc_header
            );
   }


#define _NS_HOC_SECTION_MAX_POINTS  400
nssize ____ns_hoc_section_num_points;


NS_PRIVATE NsError _ns_hoc_write_soma
   (
   NsFile        *file,
   nssize         conn_comp,
   nssize         num_conn_comp,
   const nschar  *soma_ident
   )
   {
   if( 1 < num_conn_comp )
      return ns_file_print(
               file,
               NS_FMT_STRING
               "["
               NS_FMT_ULONG
               "]",
               soma_ident,
               conn_comp
               );
   else
      return ns_file_print(
               file,
               NS_FMT_STRING,
               soma_ident
               );
   }


NS_PRIVATE NsError _ns_hoc_write_dend
   (
   NsFile        *file,
   nssize         index,
   const nschar  *dend_ident
   )
   {
   return ns_file_print(
            file,
            NS_FMT_STRING
            "["
            NS_FMT_LONG
            "]",
            dend_ident,
            index
            );
   }


NS_PRIVATE NsError _ns_hoc_write_connection
   (
   NsFile        *file,
   nssize         conn_comp,
   nssize         num_conn_comp,
   nssize         parent_dend,
   nssize         curr_dend,
   nssize         num_dend,
   const nschar  *soma_ident,
   const nschar  *dend_ident
   )
   {
   NsError error;

   if( NS_FAILURE( ns_file_print( file, "connect " ), error ) )
      return error;

   if( NS_FAILURE( _ns_hoc_write_dend( file, curr_dend, dend_ident ), error ) )
      return error;

   if( NS_FAILURE( ns_file_print( file, "(0), " ), error ) )
      return error;

   if( parent_dend == num_dend )
      {
      if( NS_FAILURE( _ns_hoc_write_soma( file, conn_comp, num_conn_comp, soma_ident ), error ) )
         return error;

      if( NS_FAILURE( ns_file_print( file, "(0.5)" NS_STRING_NEWLINE ), error ) )
         return error;
      }
   else
      {
      if( NS_FAILURE( _ns_hoc_write_dend( file, parent_dend, dend_ident ), error ) )
         return error;

      if( NS_FAILURE( ns_file_print( file, "(1)" NS_STRING_NEWLINE ), error ) )
         return error;
      }

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_do_write_connections
   (
   NsFile         *file,
   nsmodelvertex   parent_vertex,
   nsmodeledge     parent_to_curr_edge,
   nsmodelvertex   curr_vertex,
   nssize          conn_comp,
   nssize          num_conn_comp,
   nssize          parent_dend,
   nssize          num_dend,
   const nschar   *soma_ident,
   const nschar   *dend_ident
   )
   {
   nsmodelvertex  dest_vertex;
   nsmodeledge    curr_edge;
   nsmodeledge    end_edges;
   nsulong        curr_dend;
   NsError        error;


	ns_assert( ! ns_model_vertex_is_origin( curr_vertex ) );
	ns_assert( NS_MODEL_FUNCTION_SOMA != ns_model_vertex_get_function_type( curr_vertex ) );

   if( ns_model_vertex_is_external( curr_vertex ) || ns_model_vertex_is_junction( curr_vertex ) )
      {
      curr_dend = ns_model_edge_get_section( parent_to_curr_edge );
      ns_assert( 0 < curr_dend && curr_dend <= num_dend );

      /* Go from a 1-based index to a 0-based index. */
      --curr_dend;

      if( NS_FAILURE(
            _ns_hoc_write_connection(
               file,
               conn_comp,
               num_conn_comp,
               parent_dend,
               curr_dend,
               num_dend,
               soma_ident,
               dend_ident
               ),
            error ) )
         return error;

      parent_dend = curr_dend;
      }

   curr_edge = ns_model_vertex_begin_edges( curr_vertex );
   end_edges = ns_model_vertex_end_edges( curr_vertex );

   for( ; ns_model_edge_not_equal( curr_edge, end_edges );
          curr_edge = ns_model_edge_next( curr_edge ) )
      {
      dest_vertex = ns_model_edge_dest_vertex( curr_edge );

		if( ns_model_vertex_not_equal( dest_vertex, parent_vertex ) )
         if( NS_FAILURE(
               _ns_hoc_do_write_connections(
                  file,
                  curr_vertex,
                  curr_edge,
                  dest_vertex,
                  conn_comp,
                  num_conn_comp,
                  parent_dend,
                  num_dend,
                  soma_ident,
                  dend_ident
                  ),
               error ) )
            return error;
      }

	return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_write_connections
   (
   NsFile         *file,
   nsmodeltree     tree,
   nssize          num_conn_comp,
   nssize          num_dend,
   const nschar   *soma_ident,
   const nschar   *dend_ident
   )
   {
	nsmodelvertex  parent;
	nsmodelvertex  root;
   nsmodeledge    edge;


	parent = ns_model_tree_parent( tree );
	root   = ns_model_tree_root( tree );

	edge = ns_model_vertex_find_edge( parent, root );
	ns_assert( ns_model_edge_not_equal( edge, ns_model_vertex_end_edges( parent ) ) );

   return _ns_hoc_do_write_connections(
            file,
            parent,
            edge,
            root,
            ns_model_tree_conn_comp( tree ),
            num_conn_comp,
            num_dend,
            num_dend,
            soma_ident,
            dend_ident
            );
   }


NS_PRIVATE NsError _ns_hoc_write_create_soma
   (
   NsFile        *file,
   nssize         num_conn_comp,
   const nschar  *soma_ident
   )
   {
   NsError error;

   if( 0 < num_conn_comp )
      {
      if( NS_FAILURE( ns_file_print( file, "create " ), error ) )
         return error;

      if( NS_FAILURE(
            _ns_hoc_write_soma(
               file,
               num_conn_comp,
               num_conn_comp,
               soma_ident
               ),
            error ) )
         return error;

      if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE ), error ) )
         return error;
      }

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_write_create_dend
   (
   NsFile        *file,
   nssize         num_dend,
   const nschar  *dend_ident
   )
   {
   NsError error;

	if( 0 < num_dend )
		{
		if( NS_FAILURE( ns_file_print( file, "create " ), error ) )
			return error;

		if( NS_FAILURE( _ns_hoc_write_dend( file, num_dend, dend_ident ), error ) )
			return error;

		if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE ), error ) )
			return error;
		}

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_write_soma_access
   (
   NsFile        *file,
   nssize         conn_comp,
   nssize         num_conn_comp,
   const nschar  *soma_ident
   )
   {
   NsError error;

   if( NS_FAILURE( ns_file_print( file, "access " ), error ) )
      return error;

   if( NS_FAILURE(
         _ns_hoc_write_soma(
            file,
            conn_comp,
            num_conn_comp,
            soma_ident
            ),
         error ) )
      return error;

   if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE ), error ) )
      return error;

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_write_dend_begin
   (
   NsFile        *file,
   nssize         index,
   const nschar  *dend_ident
   )
   {
   NsError error;

	if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE ), error ) )
		return error;

   if( NS_FAILURE( _ns_hoc_write_dend( file, index, dend_ident ), error ) )
      return error;
   
   if( NS_FAILURE(
         ns_file_print(
            file,
            " {"
            NS_STRING_NEWLINE
            NS_STRING_TAB "pt3dclear()"
            NS_STRING_NEWLINE
            ),
         error ) )
      return error;

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_write_dend_end( NsFile *file )
   {
	____ns_hoc_section_num_points = 0;
	return ns_file_print( file, NS_STRING_NEWLINE NS_STRING_TAB "}" NS_STRING_NEWLINE );
	}


NS_PRIVATE NsError _ns_hoc_write_point
   (
   NsFile            *file,
   const NsVector3f  *position,
   nsfloat            radius
   )
   {
   return ns_file_print(
            file,
            "pt3dadd("
            NS_FMT_DOUBLE
            ","
            NS_FMT_DOUBLE
            ","
            NS_FMT_DOUBLE
            ","
            NS_FMT_DOUBLE
            ")",
            position->x,
            position->y,
            position->z,
            radius * 2.0f /* .hoc stores diameters! */
            );
   }


NS_PRIVATE NsError _ns_hoc_do_write_dend_points
   (
   NsFile            *file,
   nsmodelvertex      parent_vertex,
   nsmodelvertex      curr_vertex,
   nssize             curr_dend,
   nssize             num_dend,
   const nschar      *dend_ident,
	const NsVector3f  *soma_position,
	nsfloat            soma_radius
   )
   {
   nsmodelvertex  dest_vertex;
   nsmodeledge    curr_edge;
   nsmodeledge    end_edges;
   nsboolean      dend_end;
   NsVector3f     position;
   nsfloat        radius;
   NsError        error;


   /* NOTE: Every vertex writes its parent's info. */

   ns_assert( ! ns_model_vertex_is_origin( curr_vertex ) );

	if( NS_MODEL_FUNCTION_SOMA == ns_model_vertex_get_function_type( parent_vertex ) )
		{
		position = *soma_position;
		radius   = soma_radius;
		}
	else
		{
		ns_model_vertex_get_position( parent_vertex, &position );
		radius = ns_model_vertex_get_radius( parent_vertex );
		}

   if( NS_FAILURE( ns_file_print( file, NS_STRING_TAB ), error ) )
      return error;

   if( NS_FAILURE( _ns_hoc_write_point( file, &position, radius ), error ) )
      return error;

   if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE ), error ) )
      return error;


	/* There is some kind of bug in the NEURON .HOC file reader program where adding
		too many points to a section in one block causes an error with a message
		"procedure too big", or something to that effect. */
	++____ns_hoc_section_num_points;

	if( ____ns_hoc_section_num_points >= _NS_HOC_SECTION_MAX_POINTS )
		{
#ifdef NS_DEBUG
		ns_warning(
			NS_WARNING_LEVEL_CAUTION
			NS_MODULE
			" .HOC: The adding of points to NEURON section " NS_FMT_ULONG " needs to be broken up." NS_STRING_NEWLINE,
			curr_dend
			);
#endif

		____ns_hoc_section_num_points = 0;

		if( NS_FAILURE( ns_file_print( file, NS_STRING_TAB "}" NS_STRING_NEWLINE NS_STRING_NEWLINE ), error ) )
			return error;

		if( NS_FAILURE( _ns_hoc_write_dend( file, curr_dend, dend_ident ), error ) )
			return error;

		if( NS_FAILURE( ns_file_print( file, " {" NS_STRING_NEWLINE ), error ) )
			return error;
		}


   dend_end = ns_model_vertex_is_external( curr_vertex ) || ns_model_vertex_is_junction( curr_vertex );

   if( dend_end )
      {
      /* End of dendrite so write the current's position. */
      ns_model_vertex_get_position( curr_vertex, &position );
      radius = ns_model_vertex_get_radius( curr_vertex );

      if( NS_FAILURE( ns_file_print( file, NS_STRING_TAB ), error ) )
         return error;

      if( NS_FAILURE( _ns_hoc_write_point( file, &position, radius ), error ) )
         return error;

      if( NS_FAILURE( _ns_hoc_write_dend_end( file ), error ) )
         return error;
      }

   curr_edge = ns_model_vertex_begin_edges( curr_vertex );
   end_edges = ns_model_vertex_end_edges( curr_vertex );

   for( ; ns_model_edge_not_equal( curr_edge, end_edges );
          curr_edge = ns_model_edge_next( curr_edge ) )
      {
      dest_vertex = ns_model_edge_dest_vertex( curr_edge );

      if( ns_model_vertex_not_equal( dest_vertex, parent_vertex ) )
         {
         if( dend_end )
            {
            curr_dend = ns_model_edge_get_section( curr_edge );
            ns_assert( 0 < curr_dend && curr_dend <= num_dend );

            /* Go from a 1-based index to a 0-based index. */
            --curr_dend;

            if( NS_FAILURE( _ns_hoc_write_dend_begin( file, curr_dend, dend_ident ), error ) )
               return error;
            }

         if( NS_FAILURE(
               _ns_hoc_do_write_dend_points(
                  file,
                  curr_vertex,
                  dest_vertex,
                  curr_dend,
                  num_dend,
                  dend_ident,
						soma_position,
						soma_radius
                  ),
               error ) )
            return error;
         }
      }

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_write_dend_points
   (
   NsFile            *file,
	nsmodeltree        tree,
   nssize             num_dend,
   const nschar      *dend_ident,
	const NsVector3f  *soma_position,
	nsfloat            soma_radius
   )
   {
	nsmodelvertex  parent;
	nsmodelvertex  root;
   nsmodeledge    edge;
   nsulong        curr_dend;
	NsError        error;


	parent = ns_model_tree_parent( tree );
	root   = ns_model_tree_root( tree );

	edge = ns_model_vertex_find_edge( parent, root );
	ns_assert( ns_model_edge_not_equal( edge, ns_model_vertex_end_edges( parent ) ) );

	curr_dend = ns_model_edge_get_section( edge );
	ns_assert( 0 < curr_dend && curr_dend <= num_dend );

	/* Go from a 1-based index to a 0-based index. */
	--curr_dend;

	if( NS_FAILURE( _ns_hoc_write_dend_begin( file, curr_dend, dend_ident ), error ) )
		return error;

	if( NS_FAILURE(
			_ns_hoc_do_write_dend_points(
				file,
				parent,
				root,
				curr_dend,
				num_dend,
				dend_ident,
				soma_position,
				soma_radius
				),
			error ) )
		return error;

	return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_do_create_soma_spheres
	(
	NsList         *spheres,
	NsVector3d     *total_min,
	NsVector3d     *total_max,
	nsmodelvertex   parent_vertex,
	nsmodelvertex   curr_vertex,
	NsVector3d     *center,
	nsdouble       *sum_radii
	)
	{
	NsSphered      *S;
	nsmodelvertex   dest_vertex;
	nsmodeledge     curr_edge, end_edges;
	NsVector3d      curr_min, curr_max;
	NsVector3d      R, V;
	NsError         error;


	ns_assert( NS_MODEL_FUNCTION_SOMA == ns_model_vertex_get_function_type( curr_vertex ) );

	/* Create the sphere and add it to the list. */

	if( NULL == ( S = ns_new( NsSphered ) ) )
		return ns_error_nomem( NS_ERROR_LEVEL_CRITICAL, NS_MODULE );

	ns_model_vertex_to_sphere_ex( curr_vertex, S );

	if( NS_FAILURE( ns_list_push_back( spheres, S ), error ) )
		{
		ns_free( S );
		return error;
		}

	ns_assert( 0.0 <= S->r );

	/* Get the bounding cube of the current sphere. */
	ns_vector3d( &R, S->r, S->r, S->r );
	ns_vector3d_sub( &curr_min, &S->O, &R );
	ns_vector3d_add( &curr_max, &S->O, &R );

	/* Adjust the total bounding box. */
	if( curr_min.x < total_min->x )total_min->x = curr_min.x;
	if( curr_min.y < total_min->y )total_min->y = curr_min.y;
	if( curr_min.z < total_min->z )total_min->z = curr_min.z;
	if( curr_max.x > total_max->x )total_max->x = curr_max.x;
	if( curr_max.y > total_max->y )total_max->y = curr_max.y;
	if( curr_max.z > total_max->z )total_max->z = curr_max.z;

	/* Add to the computation of the centroid. */

	*sum_radii += S->r;

	V = S->O;
	ns_vector3d_cmpd_scale( &V, S->r );
	ns_vector3d_cmpd_add( center, &V );

	/* Recurse... */

   curr_edge = ns_model_vertex_begin_edges( curr_vertex );
   end_edges = ns_model_vertex_end_edges( curr_vertex );

   for( ; ns_model_edge_not_equal( curr_edge, end_edges );
          curr_edge = ns_model_edge_next( curr_edge ) )
      {
      dest_vertex = ns_model_edge_dest_vertex( curr_edge );

      if( ns_model_vertex_not_equal( dest_vertex, parent_vertex ) &&
			 NS_MODEL_FUNCTION_SOMA == ns_model_vertex_get_function_type( dest_vertex ) )
			if( NS_FAILURE(
					_ns_hoc_do_create_soma_spheres(
						spheres,
						total_min,
						total_max,
						curr_vertex,
						dest_vertex,
						center,
						sum_radii
						),
					error ) )
				return error;
		}

	return ns_no_error();
	}


NS_PRIVATE nsboolean _ns_hoc_soma_spheres_order_func( const NsSphered *S1, const NsSphered *S2 )
	{  return S1->r > S2->r;  }


NS_PRIVATE NsError _ns_hoc_write_soma_point_single
   (
   NsFile             *file,
	NsModel            *model,
   nssize              conn_comp,
   nssize              num_conn_comp,
	const NsVoxelInfo  *voxel_info,
   const nschar       *soma_ident,
	NsVector3f         *soma_position,
	nsfloat            *soma_radius
   )
   {
	nsmodelorigin     origin;
	nsmodelvertex     vertex;
	NsVector3d        min, max;
	NsVector3d        center;
	NsVector3d        voxel_size;
	NsVector3d        P, V;
	NsVector3f        position;
	nsdouble          sum_radii;
	NsList            spheres;
	nslistiter        curr_sphere;
	nslistiter        end_spheres;
	const NsSphered  *S;
	nsdouble          length_sq;
	nssize            count;
	nsdouble          volume;
	nsfloat           radius;
	NsError           error;


	/* Find all the soma points and store them as spheres in a list. At the same
		time compute the minimum bounding box that encompasses all those spheres,
		and the center of mass of the spheres. */

	ns_list_construct( &spheres, ns_free );

	origin = ns_model_find_origin_by_conn_comp( model, conn_comp );
	ns_assert( ns_model_origin_not_equal( origin, NS_MODEL_ORIGIN_NIL ) );

	vertex = ns_model_origin_vertex( origin );

	ns_vector3d( &min, NS_DOUBLE_MAX, NS_DOUBLE_MAX, NS_DOUBLE_MAX );
	ns_vector3d( &max, -NS_DOUBLE_MAX, -NS_DOUBLE_MAX, -NS_DOUBLE_MAX );

	ns_vector3d_zero( &center );
	sum_radii = 0.0;

	if( NS_FAILURE(
			_ns_hoc_do_create_soma_spheres(
				&spheres,
				&min,
				&max,
				NS_MODEL_VERTEX_NIL,
				vertex,
				&center,
				&sum_radii
				),
			error ) )
		{
		ns_list_destruct( &spheres );
		return error;
		}

	/* Note that if we only have one soma vertex, then the intersection problem
		is obviously not present, so just use this one vertex. */
	if( 1 == ns_list_size( &spheres ) )
		{
		ns_model_vertex_get_position( vertex, &position );
		radius = ns_model_vertex_get_radius( vertex );
		}
	else
		{
		ns_assert( 2 <= ns_list_size( &spheres ) );

		/* Now actually compute the centroid. */
		ns_vector3d_cmpd_scale( &center, 1.0f / sum_radii );
		ns_vector3d_to_3f( &center, &position );

		/* Sort the list from biggest sphere to smallest. In the loops that follow
			this will make more voxels terminate at the first node in the list. */
		ns_list_sort( &spheres, _ns_hoc_soma_spheres_order_func );

		count = 0;

		ns_vector3f_to_3d( ns_voxel_info_size( voxel_info ), &voxel_size );

		/* Now check each voxel in the bounding box to see if it lies
			within any of the spheres. */
		for( P.z = min.z; P.z <= max.z; P.z += voxel_size.z )
			for( P.y = min.y; P.y <= max.y; P.y += voxel_size.y )
				for( P.x = min.x; P.x <= max.x; P.x += voxel_size.x )
					{
					curr_sphere = ns_list_begin( &spheres );
					end_spheres = ns_list_end( &spheres );

					for( ; ns_list_iter_not_equal( curr_sphere, end_spheres );
							 curr_sphere = ns_list_iter_next( curr_sphere ) )
						{
						S = ns_list_iter_get_object( curr_sphere );

						ns_vector3d_sub( &V, &P, &S->O );
						length_sq = NS_DISTANCE_SQUARED( V.x, V.y, V.z, 0.0, 0.0, 0.0 );

						/* If this voxel intersects a sphere, then add it to the total
							count. This is the easiest way to approximate the volume of
							all the soma sphere's, which could intersect in any arbitrary
							way. */
						if( length_sq <= NS_POW2( S->r ) )
							{
							++count;
							break;
							}
						}
					}

		volume = ns_voxel_info_volume( voxel_info ) * ( nsdouble )count;
		radius = ( nsfloat )( ns_pow( ( ( 3.0 / 4.0 ) * volume ) / NS_PI_D, 1.0 / 3.0 ) );
		}

	ns_list_destruct( &spheres );

	/* So now we have a position and a radius for one soma vertex. But a HOC
		section needs 2 points minimum, so we can create an artificial that
		is slightly offset in Z. */

	if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE ), error ) )
		return error;

   if( NS_FAILURE(
         _ns_hoc_write_soma(
            file,
            conn_comp,
            num_conn_comp,
            soma_ident
            ),
         error ) )
      return error;

   if( NS_FAILURE(
         ns_file_print(
            file,
            " {" NS_STRING_NEWLINE NS_STRING_TAB "pt3dclear()" NS_STRING_NEWLINE NS_STRING_TAB
            ),
         error ) )
      return error;

   if( NS_FAILURE( _ns_hoc_write_point( file, &position, radius ), error ) )
      return error;

   if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE NS_STRING_TAB ), error ) )
      return error;

   /* NOTE: Avoid zero length cylinder by offsetting
      the origin's z coordinate. */
   position.z += ns_voxel_info_size_z( voxel_info );

   if( NS_FAILURE( _ns_hoc_write_point( file, &position, radius ), error ) )
      return error;

   if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE NS_STRING_TAB "}" NS_STRING_NEWLINE ), error ) )
      return error;

	*soma_position = position;
	*soma_radius   = radius;

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_hoc_write_soma_points
   (
   NsFile             *file,
	NsModel            *model,
   nssize              conn_comp,
   nssize              num_conn_comp,
	const NsVoxelInfo  *voxel_info,
   const nschar       *soma_ident,
	NsVector3f         *soma_position,
	nsfloat            *soma_radius
   )
   {
	/* This routine can be replaced as necessary. */
	return _ns_hoc_write_soma_point_single(
				file,
				model,
				conn_comp,
				num_conn_comp,
				voxel_info,
				soma_ident,
				soma_position,
				soma_radius
				);
   }


NS_PRIVATE NsError _ns_hoc_write_section_lists_enter_proc
	(
	NsFile  *file,
	nssize   conn_comp,
	nssize   num_conn_comp
	)
	{
	if( 0 == num_conn_comp )
		return ns_no_error();

	return ( 1 < num_conn_comp ) ?
				ns_file_print(
					file,
					NS_STRING_NEWLINE
					"proc section_lists"
					NS_FMT_ULONG
					"() { "
					"local i"
					NS_STRING_NEWLINE,
					conn_comp
					)
					:
				ns_file_print(
					file,
					NS_STRING_NEWLINE
					"proc section_lists() { local i"
					NS_STRING_NEWLINE
					);
	}


NS_PRIVATE NsError _ns_hoc_write_section_lists_exit_proc
	(
	NsFile  *file,
	nssize   conn_comp,
	nssize   num_conn_comp
	)
	{
	if( 0 == num_conn_comp )
		return ns_no_error();

	return ( 1 < num_conn_comp ) ?
				ns_file_print(
					file,
					NS_STRING_TAB
					"}"
					NS_STRING_NEWLINE
					NS_STRING_NEWLINE
					"section_lists"
					NS_FMT_ULONG
					"()"
					NS_STRING_NEWLINE,
					conn_comp
					)
					:
				ns_file_print(
					file,
					NS_STRING_TAB
					"}"
					NS_STRING_NEWLINE
					NS_STRING_NEWLINE
					"section_lists()"
					NS_STRING_NEWLINE
					);
	}


/* TEMP? Should the invalids be listed as comments only?
	NOTE: "single_single" means 1 connected component and 1 tree... */
NS_PRIVATE NsError _ns_hoc_write_declare_section_list
	(
	NsFile        *file,
	const NsList  *sections,
	const nschar  *list_ident,
	nssize         num_lists,
	nsboolean      is_invalid_list,
	nssize         conn_comp,
	nssize         num_conn_comp
	)
	{
	const nschar  *format;
	NsError        error;


	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_single_single_normal_format =
		"objref " NS_FMT_STRING NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_single_single_invalid_format =
		"/* objref " NS_FMT_STRING "*/" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_single_multi_normal_format =
		"objref " NS_FMT_STRING "[" NS_FMT_ULONG "]" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_single_multi_invalid_format =
		"/* objref " NS_FMT_STRING "[" NS_FMT_ULONG "] */" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_multi_single_normal_format =
		"objref " NS_FMT_STRING NS_FMT_ULONG NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_multi_single_invalid_format =
		"/* objref " NS_FMT_STRING NS_FMT_ULONG " */" NS_STRING_NEWLINE;
		
	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_multi_multi_normal_format =
		"objref " NS_FMT_STRING NS_FMT_ULONG "[" NS_FMT_ULONG "]" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_create_multi_multi_invalid_format =
		"/* objref " NS_FMT_STRING NS_FMT_ULONG "[" NS_FMT_ULONG "] */" NS_STRING_NEWLINE;

	if( 0 == num_conn_comp || 0 == num_lists || ns_list_is_empty( sections ) )
		return ns_no_error();

	if( 1 < num_conn_comp )
		{
		if( 1 < num_lists )
			{
			format = is_invalid_list ?
							____ns_hoc_section_list_create_multi_multi_invalid_format :
							____ns_hoc_section_list_create_multi_multi_normal_format;

			if( NS_FAILURE( ns_file_print( file, format, list_ident, conn_comp, num_lists ), error ) )
				return error;
			}
		else
			{
			format = is_invalid_list ?
							____ns_hoc_section_list_create_multi_single_invalid_format :
							____ns_hoc_section_list_create_multi_single_normal_format;

			if( NS_FAILURE( ns_file_print( file, format, list_ident, conn_comp ), error ) )
				return error;
			}
		}
	else
		{
		if( 1 < num_lists )
			{
			format = is_invalid_list ?
							____ns_hoc_section_list_create_single_multi_invalid_format :
							____ns_hoc_section_list_create_single_multi_normal_format;

			if( NS_FAILURE( ns_file_print( file, format, list_ident, num_lists ), error ) )
				return error;
			}
		else
			{
			format = is_invalid_list ?
							____ns_hoc_section_list_create_single_single_invalid_format :
							____ns_hoc_section_list_create_single_single_normal_format;

			if( NS_FAILURE( ns_file_print( file, format, list_ident ), error ) )
				return error;
			}
		}

	return ns_no_error();
	}


typedef struct _NsHocSection
	{
	nssize  list_index;
	nssize  dend_index;
	}
	NsHocSection;


NS_PRIVATE NsError _ns_hoc_write_section_list_entries
	(
	NsFile        *file,
	const nschar  *dend_ident,
	const NsList  *sections,
	const nschar  *list_ident,
	nssize         num_lists,
	nsboolean      is_invalid_list,
	nssize         conn_comp,
	nssize         num_conn_comp
	)
	{
	nslistiter           curr;
	const NsHocSection  *section;
	const nschar        *format;
	NsError              error;


	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_single_single_normal_format =
		NS_STRING_TAB NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING ".append()" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_single_single_invalid_format =
		NS_STRING_TAB "/* " NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING ".append() */" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_single_multi_normal_format =
		NS_STRING_TAB NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING "[" NS_FMT_ULONG "].append()" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_single_multi_invalid_format =
		NS_STRING_TAB "/* " NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING "[" NS_FMT_ULONG "].append() */" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_multi_single_normal_format =
		NS_STRING_TAB NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING NS_FMT_ULONG ".append()" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_multi_single_invalid_format =
		NS_STRING_TAB "/* " NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING NS_FMT_ULONG ".append() */" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_multi_multi_normal_format =
		NS_STRING_TAB NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING NS_FMT_ULONG "[" NS_FMT_ULONG "].append()" NS_STRING_NEWLINE;

	NS_PRIVATE const nschar* ____ns_hoc_section_list_entry_multi_multi_invalid_format =
		NS_STRING_TAB "/* " NS_FMT_STRING "[" NS_FMT_ULONG "] " NS_FMT_STRING NS_FMT_ULONG "[" NS_FMT_ULONG "].append() */" NS_STRING_NEWLINE;

	NS_LIST_FOREACH( sections, curr )
		{
		section = ns_list_iter_get_object( curr );

		if( 1 < num_conn_comp )
			{
			if( 1 < num_lists )
				{
				format = is_invalid_list ?
								____ns_hoc_section_list_entry_multi_multi_invalid_format :
								____ns_hoc_section_list_entry_multi_multi_normal_format;

				if( NS_FAILURE(
						ns_file_print(
							file,
							format,
							dend_ident,
							section->dend_index,
							list_ident,
							conn_comp,
							section->list_index
							),
						error ) )
					return error;
				}
			else
				{
				format = is_invalid_list ?
								____ns_hoc_section_list_entry_multi_single_invalid_format :
								____ns_hoc_section_list_entry_multi_single_normal_format;

				if( NS_FAILURE(
						ns_file_print(
							file,
							format,
							dend_ident,
							section->dend_index,
							list_ident,
							conn_comp
							),
						error ) )
					return error;
				}
			}
		else
			{
			if( 1 < num_lists )
				{
				format = is_invalid_list ?
								____ns_hoc_section_list_entry_single_multi_invalid_format :
								____ns_hoc_section_list_entry_single_multi_normal_format;

				if( NS_FAILURE(
						ns_file_print(
							file,
							format,
							dend_ident,
							section->dend_index,
							list_ident,
							section->list_index
							),
						error ) )
					return error;
				}
			else
				{
				format = is_invalid_list ?
								____ns_hoc_section_list_entry_single_single_invalid_format :
								____ns_hoc_section_list_entry_single_single_normal_format;

				if( NS_FAILURE(
						ns_file_print(
							file,
							format,
							dend_ident,
							section->dend_index,
							list_ident
							),
						error ) )
					return error;
				}
			}
		}

	return ns_no_error();
	}


NS_PRIVATE NsError _ns_hoc_write_create_section_list
	(
	NsFile        *file,
	const nschar  *dend_ident,
	const NsList  *sections,
	const nschar  *list_ident,
	nssize         num_lists,
	nsboolean      is_invalid_list,
	nssize         conn_comp,
	nssize         num_conn_comp
	)
	{
	NsError error;

	NS_USE_VARIABLE( dend_ident );

	if( 0 == num_conn_comp || 0 == num_lists || ns_list_is_empty( sections ) )
		return ns_no_error();

	if( 1 < num_conn_comp )
		{
		if( 1 < num_lists )
			{
			if( ! is_invalid_list )
				if( NS_FAILURE(
						ns_file_print(
							file,
							NS_STRING_NEWLINE
							NS_STRING_TAB
							"for i = 0, "
							NS_FMT_ULONG
							" "
							NS_FMT_STRING NS_FMT_ULONG "[i]"
							" = new SectionList()"
							NS_STRING_NEWLINE
							NS_STRING_NEWLINE,
							num_lists - 1,
							list_ident,
							conn_comp
							),
						error ) )
					return error;
			}
		else
			{
			if( ! is_invalid_list )
				if( NS_FAILURE(
						ns_file_print(
							file,
							NS_STRING_NEWLINE
							NS_STRING_TAB
							NS_FMT_STRING NS_FMT_ULONG
							" = new SectionList()"
							NS_STRING_NEWLINE
							NS_STRING_NEWLINE,
							list_ident,
							conn_comp
							),
						error ) )
					return error;
			}
		}
	else
		{
		if( 1 < num_lists )
			{
			if( ! is_invalid_list )
				if( NS_FAILURE(
						ns_file_print(
							file,
							NS_STRING_NEWLINE
							NS_STRING_TAB
							"for i = 0, "
							NS_FMT_ULONG
							" "
							NS_FMT_STRING "[i]"
							" = new SectionList()"
							NS_STRING_NEWLINE
							NS_STRING_NEWLINE,
							num_lists - 1,
							list_ident
							),
						error ) )
					return error;
			}
		else
			{
			if( ! is_invalid_list )
				if( NS_FAILURE(
						ns_file_print(
							file,
							NS_STRING_NEWLINE
							NS_STRING_TAB
							NS_FMT_STRING
							" = new SectionList()"
							NS_STRING_NEWLINE
							NS_STRING_NEWLINE,
							list_ident
							),
						error ) )
					return error;
			}
		}

	return ns_no_error();
	}


NS_PRIVATE NsError _ns_hoc_do_create_section_lists
   (
	NsList         *sections,
	nsmodeltree     tree,
   nsmodelvertex   parent_vertex,
   nsmodelvertex   curr_vertex,
   nssize          curr_dend,
   nssize          num_dend
   )
   {
   nsboolean       dend_end;
   nsmodeledge     curr_edge;
   nsmodeledge     end_edges;
   nsmodelvertex   dest_vertex;
	NsHocSection   *section;
	nssize          next_dend;
   NsError         error;


   ns_assert( NS_MODEL_FUNCTION_SOMA != ns_model_vertex_get_function_type( curr_vertex ) );

   dend_end = ns_model_vertex_is_external( curr_vertex ) || ns_model_vertex_is_junction( curr_vertex );

	if( dend_end )
		{
		if( NULL == ( section = ns_new( NsHocSection ) ) )
			return ns_error_nomem( NS_ERROR_LEVEL_CRITICAL, NS_MODULE );

		section->list_index = ns_model_tree_type_index( tree );
		section->dend_index = curr_dend;

		if( NS_FAILURE( ns_list_push_back( sections, section ), error ) )
			{
			ns_free( section );
			return error;
			}
		}

   curr_edge = ns_model_vertex_begin_edges( curr_vertex );
   end_edges = ns_model_vertex_end_edges( curr_vertex );

   for( ; ns_model_edge_not_equal( curr_edge, end_edges );
          curr_edge = ns_model_edge_next( curr_edge ) )
      {
      dest_vertex = ns_model_edge_dest_vertex( curr_edge );

      if( ns_model_vertex_not_equal( dest_vertex, parent_vertex ) )
         {
			next_dend = ns_model_edge_get_section( curr_edge );

         if( dend_end )
				{
            ns_assert( 0 < next_dend && next_dend <= num_dend );

            /* Go from a 1-based index to a 0-based index. */
            --next_dend;
            }
			else
				{
				ns_assert( next_dend - 1 == curr_dend );
				next_dend = curr_dend;
				}

         if( NS_FAILURE(
               _ns_hoc_do_create_section_lists(
						sections,
						tree,
                  curr_vertex,
                  dest_vertex,
                  next_dend,
                  num_dend
                  ),
               error ) )
            return error;
         }
      }

   return ns_no_error();
   }


NS_PRIVATE NsError _ns_how_write_section_lists
	(
	NsFile        *file,
	NsModel       *model,
	nssize         conn_comp,
	nssize         num_conn_comp,
	nssize         num_dend,
   const nschar  *dend_ident,
	const nschar  *invalid_sections_ident,
	const nschar  *unknown_sections_ident,
	const nschar  *soma_sections_ident,
	const nschar  *basal_dendrite_sections_ident,
	const nschar  *apical_dendrite_sections_ident,
	const nschar  *axon_sections_ident
	)
	{
	NsList          invalid_sections;
	NsList          unknown_sections;
	NsList          soma_sections;
	NsList          basal_dendrite_sections;
	NsList          apical_dendrite_sections;
	NsList          axon_sections;
	nssize          num_unknown_lists;
	nssize          num_basal_dendrite_lists;
	nssize          num_apical_dendrite_lists;
	nssize          num_axon_lists;
	nsmodeltree     curr_tree;
	nsmodeltree     end_trees;
	NsList         *sections;
	nsmodelvertex   parent;
	nsmodelvertex   root;
	nsmodeledge     edge;
	nssize          curr_dend;
   NsError         error;


	error = ns_no_error();

	ns_list_construct( &invalid_sections, ns_free );
	ns_list_construct( &unknown_sections, ns_free );
	ns_list_construct( &soma_sections, ns_free );
	ns_list_construct( &basal_dendrite_sections, ns_free );
	ns_list_construct( &apical_dendrite_sections, ns_free );
	ns_list_construct( &axon_sections, ns_free );

	num_unknown_lists         = 0;
	num_basal_dendrite_lists  = 0;
	num_apical_dendrite_lists = 0;
	num_axon_lists            = 0;

   curr_tree = ns_model_begin_trees( model );
   end_trees = ns_model_end_trees( model );

   for( ; ns_model_tree_not_equal( curr_tree, end_trees );
          curr_tree = ns_model_tree_next( curr_tree ) )
		if( ns_model_tree_conn_comp( curr_tree ) == conn_comp )
			{
			sections = NULL;

			switch( ns_model_tree_function_type( curr_tree ) )
				{
				case NS_MODEL_FUNCTION_UNKNOWN:
					sections = &unknown_sections;
					++num_unknown_lists;
					break;

				case NS_MODEL_FUNCTION_BASAL_DENDRITE:
					sections = &basal_dendrite_sections;
					++num_basal_dendrite_lists;
					break;

				case NS_MODEL_FUNCTION_APICAL_DENDRITE:
					sections = &apical_dendrite_sections;
					++num_apical_dendrite_lists;
					break;

				case NS_MODEL_FUNCTION_AXON:
					sections = &axon_sections;
					++num_axon_lists;
					break;

				case NS_MODEL_FUNCTION_INVALID:
					sections = &invalid_sections;
					break;

				default:
					ns_assert_not_reached();
				}

			parent = ns_model_tree_parent( curr_tree );
			root   = ns_model_tree_root( curr_tree );

			edge = ns_model_vertex_find_edge( parent, root );
			ns_assert( ns_model_edge_not_equal( edge, ns_model_vertex_end_edges( parent ) ) );

			curr_dend = ns_model_edge_get_section( edge );
			ns_assert( 0 < curr_dend && curr_dend <= num_dend );

			/* Go from a 1-based index to a 0-based index. */
			--curr_dend;

			if( NS_FAILURE(
					_ns_hoc_do_create_section_lists(
						sections,
						curr_tree,
						parent,
						root,
						curr_dend,
						num_dend
						),
					error ) )
				goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;
			}

	if( NS_FAILURE( ns_file_print( file, NS_STRING_NEWLINE ), error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_declare_section_list(
				file,
				&invalid_sections,
				invalid_sections_ident,
				1,
				NS_TRUE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_declare_section_list(
				file,
				&unknown_sections,
				unknown_sections_ident,
				num_unknown_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_declare_section_list(
				file,
				&soma_sections,
				soma_sections_ident,
				1,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_declare_section_list(
				file,
				&basal_dendrite_sections,
				basal_dendrite_sections_ident,
				num_basal_dendrite_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_declare_section_list(
				file,
				&apical_dendrite_sections,
				apical_dendrite_sections_ident,
				num_apical_dendrite_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_declare_section_list(
				file,
				&axon_sections,
				axon_sections_ident,
				num_axon_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE( _ns_hoc_write_section_lists_enter_proc( file, conn_comp, num_conn_comp ), error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_create_section_list(
				file,
				dend_ident,
				&invalid_sections,
				invalid_sections_ident,
				1,
				NS_TRUE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_section_list_entries(
				file,
				dend_ident,
				&invalid_sections,
				invalid_sections_ident,
				1,
				NS_TRUE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_create_section_list(
				file,
				dend_ident,
				&unknown_sections,
				unknown_sections_ident,
				num_unknown_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_section_list_entries(
				file,
				dend_ident,
				&unknown_sections,
				unknown_sections_ident,
				num_unknown_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_create_section_list(
				file,
				dend_ident,
				&soma_sections,
				soma_sections_ident,
				1,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_section_list_entries(
				file,
				dend_ident,
				&soma_sections,
				soma_sections_ident,
				1,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_create_section_list(
				file,
				dend_ident,
				&basal_dendrite_sections,
				basal_dendrite_sections_ident,
				num_basal_dendrite_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_section_list_entries(
				file,
				dend_ident,
				&basal_dendrite_sections,
				basal_dendrite_sections_ident,
				num_basal_dendrite_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_create_section_list(
				file,
				dend_ident,
				&apical_dendrite_sections,
				apical_dendrite_sections_ident,
				num_apical_dendrite_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_section_list_entries(
				file,
				dend_ident,
				&apical_dendrite_sections,
				apical_dendrite_sections_ident,
				num_apical_dendrite_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_create_section_list(
				file,
				dend_ident,
				&axon_sections,
				axon_sections_ident,
				num_axon_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE(
			_ns_hoc_write_section_list_entries(
				file,
				dend_ident,
				&axon_sections,
				axon_sections_ident,
				num_axon_lists,
				NS_FALSE,
				conn_comp,
				num_conn_comp
				),
			error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	if( NS_FAILURE( _ns_hoc_write_section_lists_exit_proc( file, conn_comp, num_conn_comp ), error ) )
		goto _NS_HOC_WRITE_SECTION_LISTS_EXIT;

	_NS_HOC_WRITE_SECTION_LISTS_EXIT:

	ns_list_destruct( &invalid_sections );
	ns_list_destruct( &unknown_sections );
	ns_list_destruct( &soma_sections );
	ns_list_destruct( &basal_dendrite_sections );
	ns_list_destruct( &apical_dendrite_sections );
	ns_list_destruct( &axon_sections );

   return error;
	}


NS_PRIVATE NsError _ns_hoc_write_single_file
   (
   NsModel            *model,
   const NsVoxelInfo  *voxel_info,
   const nschar       *file_name,
   nsulong             flags,
   const nschar       *soma_ident,
   const nschar       *dend_ident,
	const nschar       *invalid_sections_ident,
	const nschar       *unknown_sections_ident,
	const nschar       *soma_sections_ident,
	const nschar       *basal_dendrite_sections_ident,
	const nschar       *apical_dendrite_sections_ident,
	const nschar       *axon_sections_ident
   )
   {
   NsFile        file;
	nsmodeltree   curr_tree;
	nsmodeltree   end_trees;
   nssize        conn_comp;
   nssize        num_conn_comp;
   nssize        num_dend;
	NsVector3f   *soma_positions;
	nsfloat      *soma_radii;
   NsError       error;


	error = ns_no_error();

	soma_positions = NULL;
	soma_radii     = NULL;

   ns_file_construct( &file );

   if( NS_FAILURE( ns_file_open( &file, file_name, NS_FILE_MODE_WRITE ), error ) )
      goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

   /* Step 0: Write the header. */

   if( NS_FAILURE( _ns_hoc_write_header( &file ), error ) )
      goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

   num_conn_comp = ns_model_num_origins( model );

   /* Step 1a: Create the sections. */

   if( NS_FAILURE(
         _ns_hoc_write_create_soma(
            &file,
            num_conn_comp,
            soma_ident
            ),
         error ) )
      goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

   num_dend = ns_model_num_sections( model );

   if( NS_FAILURE(
         _ns_hoc_write_create_dend(
            &file,
            num_dend,
            dend_ident
            ),
            error ) )
      goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

	if( NS_FAILURE( ns_file_print( &file, NS_STRING_NEWLINE ), error ) )
      goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

	/* Step 1b: Access the soma sections, if specified. */

   if( flags & NS_HOC_ACCESS_SOMAS )
		{
      for( conn_comp = 0; conn_comp < num_conn_comp; ++conn_comp )
         if( NS_FAILURE(
               _ns_hoc_write_soma_access(
                  &file,
                  conn_comp,
                  num_conn_comp,
                  soma_ident
                  ),
               error ) )
            goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

		if( NS_FAILURE( ns_file_print( &file, NS_STRING_NEWLINE ), error ) )
			goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;
		}

   /* Step 2: Connect the sections. */

   curr_tree = ns_model_begin_trees( model );
   end_trees = ns_model_end_trees( model );

   for( ; ns_model_tree_not_equal( curr_tree, end_trees );
          curr_tree = ns_model_tree_next( curr_tree ) )
      if( NS_FAILURE(
            _ns_hoc_write_connections(
               &file,
               curr_tree,
               num_conn_comp,
               num_dend,
               soma_ident,
               dend_ident
               ),
            error ) )
         goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

	/* Step 3a: Produce the soma points. */

	if( NULL == ( soma_positions = ns_calloc( num_conn_comp, sizeof( NsVector3f ) ) ) )
		{
		error = ns_error_nomem( NS_ERROR_LEVEL_CRITICAL, NS_MODULE );
		goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;
		}

	if( NULL == ( soma_radii = ns_calloc( num_conn_comp, sizeof( nsfloat ) ) ) )
		{
		error = ns_error_nomem( NS_ERROR_LEVEL_CRITICAL, NS_MODULE );
		goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;
		}

   for( conn_comp = 0; conn_comp < num_conn_comp; ++conn_comp )
      if( NS_FAILURE(
            _ns_hoc_write_soma_points(
               &file,
					model,
               conn_comp,
               num_conn_comp,
					voxel_info,
               soma_ident,
					soma_positions + conn_comp,
					soma_radii + conn_comp
               ),
            error ) )
         goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

   /* Step 3b: Produce the dendrite points. */

   curr_tree = ns_model_begin_trees( model );
   end_trees = ns_model_end_trees( model );

   for( ; ns_model_tree_not_equal( curr_tree, end_trees );
          curr_tree = ns_model_tree_next( curr_tree ) )
		{
		conn_comp = ns_model_tree_conn_comp( curr_tree );
		ns_assert( conn_comp < num_conn_comp );

      if( NS_FAILURE(
				_ns_hoc_write_dend_points(
					&file,
					curr_tree,
					num_dend,
					dend_ident,
					soma_positions + conn_comp,
					soma_radii[ conn_comp ]
					),
				error ) )
         goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;
		}

	/* Step 4: Create the section lists */

   for( conn_comp = 0; conn_comp < num_conn_comp; ++conn_comp )
		if( NS_FAILURE(
				_ns_how_write_section_lists(
					&file,
					model,
					conn_comp,
					num_conn_comp,
					num_dend,
               dend_ident,
					invalid_sections_ident,
					unknown_sections_ident,
					soma_sections_ident,
					basal_dendrite_sections_ident,
					apical_dendrite_sections_ident,
					axon_sections_ident
					),
				error ) )
         goto _NS_HOC_WRITE_SINGLE_FILE_EXIT;

	_NS_HOC_WRITE_SINGLE_FILE_EXIT:

	ns_free( soma_positions );
	ns_free( soma_radii );

   ns_file_destruct( &file );
   return error;
   }




/*
NS_PRIVATE const nschar* _ns_hoc_ext = ".hoc";

NS_PRIVATE NsError _ns_hoc_write_multi_file
   (
   NsModel            *model,
   const NsVoxelInfo  *voxel_info,
   const nschar       *file_name,
   nsulong             flags,
   const nschar       *soma_ident,
   const nschar       *dend_ident,
	const nschar       *invalid_sections_ident,
	const nschar       *unknown_sections_ident,
	const nschar       *soma_sections_ident,
	const nschar       *basal_dendrite_sections_ident,
	const nschar       *apical_dendrite_sections_ident,
	const nschar       *axon_sections_ident
   )
   {
   NsFile         file;
   nssize         file_name_length;
   nssize         file_num_length;
   nssize         file_ext_length;
   nssize         file_num;
   nschar        *ptr;
   nschar         buffer[ NS_PATH_SIZE ] = { NS_ASCII_NULL };
   nssize         num_origins;
   nsmodelorigin  curr_origin;
   nsmodelorigin  end_origins;
   nsmodelvertex  origin;
   nssize         num_dend;
   NsError        error;


   num_origins = ns_model_num_origins( model );

   file_name_length = ns_ascii_strlen( file_name );
   file_ext_length  = ns_ascii_strlen( _ns_hoc_ext );

   /* NOTE: This will be the file number with the most digits. *//*
   if( 1 < num_origins )
      {
      if( flags & NS_HOC_FILE_NUM_ZERO_PAD )
         ns_sprint( buffer,
                    NS_MAKE_FMT( "04", NS_FMT_TYPE_ULONG ),
                    num_origins
                  );
      else
         ns_sprint( buffer, NS_FMT_ULONG, num_origins );
      }

   file_num_length = ns_ascii_strlen( buffer );

   if( NS_PATH_SIZE - 1 < file_name_length + file_num_length + file_ext_length )
      return ns_error_nametoolong( NS_ERROR_LEVEL_RECOVERABLE, NS_MODULE );

   ns_sprint( buffer, NS_FMT_STRING, file_name );

   /* Chop out the extension from the file name if its present. *//*
   ptr = ns_ascii_strrchr( buffer, '.' );
   if( NULL != ptr && ns_ascii_streq( ptr, _ns_hoc_ext ) )
      *ptr = NS_ASCII_NULL;

   /* Set a pointer to the end of the string so we can concatenate
      the file number and extension. *//*
   ptr = buffer + ns_ascii_strlen( buffer );

   file_num    = ( flags & NS_HOC_FILE_NUM_ONE_BASED ) ? 1 : 0;
   curr_origin = ns_model_begin_origins( model );
   end_origins = ns_model_end_origins( model );

   /* NOTE: The 'conn_comp' and 'num_conn_comp' parameters are not
      used when writing multiple files, they are always 0 and 1. *//*

   for( ; ns_model_origin_not_equal( curr_origin, end_origins );
          curr_origin = ns_model_origin_next( curr_origin ) )
      {
      if( 1 < num_origins )
         {
         if( flags & NS_HOC_FILE_NUM_ZERO_PAD )
            ns_sprint( ptr, NS_MAKE_FMT( "04", NS_FMT_TYPE_ULONG ), file_num );
         else
            ns_sprint( ptr, NS_FMT_ULONG, file_num );
         }

      ns_ascii_strcat( ptr, _ns_hoc_ext );

      ns_assert( ns_ascii_strlen( buffer ) <= NS_PATH_SIZE - 1 );

      origin = ns_model_origin_vertex( curr_origin );

      ns_file_construct( &file );
   
      if( NS_FAILURE( ns_file_open( &file, buffer, NS_FILE_MODE_WRITE ), error ) )
         {
         ns_file_destruct( &file );
         return error;
         }

      /* Step 0: Write the header. *//*

      if( NS_FAILURE( _ns_hoc_write_header( &file ), error ) )
         {
         ns_file_destruct( &file );
         return error;
         }

      /* Step 1: Create the structures. *//*

      if( NS_FAILURE( _ns_hoc_write_create_soma( &file, 1, soma_ident ), error ) )
         {
         ns_file_destruct( &file );
         return error;
         }

      num_dend = ns_model_conn_comp_resection( curr_origin );

      if( NS_FAILURE(
            _ns_hoc_write_create_dend(
               &file,
               num_dend,
               dend_ident
               ),
               error ) )
         {
         ns_file_destruct( &file );
         return error;
         }

      if( flags & NS_HOC_ACCESS_SOMAS )
         if( NS_FAILURE( _ns_hoc_write_soma_access( &file, 0, 1, soma_ident ), error ) )
            {
            ns_file_destruct( &file );
            return error;
            }

      /* Step 2: Connect the structures. *//*

      ns_model_color_vertices_recursive( origin, NS_MODEL_COLOR_WHITE );

      if( NS_FAILURE(
            _ns_hoc_write_connections(
               &file,
               flags,
               origin,
               0,
               1,
               num_dend,
               soma_ident,
               dend_ident
               ),
            error ) )
         {
         ns_file_destruct( &file );
         return error;
         }

      /* Step 3: Produce the points. *//*

      ns_model_color_vertices_recursive( origin, NS_MODEL_COLOR_WHITE );

      if( NS_FAILURE(
            _ns_hoc_write_points(
               &file,
					model,
               voxel_info,
               origin,
               0,
               1,
               num_dend,
               soma_ident,
               dend_ident
               ),
            error ) )
         {
         ns_file_destruct( &file );
         return error;
         }

      ns_file_destruct( &file );
      ++file_num;
      }

   return ns_no_error();
   }*/


NsError ns_model_write_hoc
   (
   NsModel            *model,
   const NsVoxelInfo  *voxel_info,
   const nschar       *file_name,
   nsulong             flags,
   const nschar       *soma_ident,
   const nschar       *dend_ident,
	const nschar       *invalid_sections_ident,
	const nschar       *unknown_sections_ident,
	const nschar       *soma_sections_ident,
	const nschar       *basal_dendrite_sections_ident,
	const nschar       *apical_dendrite_sections_ident,
	const nschar       *axon_sections_ident
   )
   {
   nsint    section_type;
   NsError  error;


   ns_assert( NULL != model );
   ns_assert( NULL != voxel_info );
   ns_assert( NULL != file_name );
   ns_assert( NULL != soma_ident );
   ns_assert( NULL != dend_ident );

   ns_log_entry(
      NS_LOG_ENTRY_FUNCTION,
      NS_FUNCTION
      "( model=" NS_FMT_STRING_DOUBLE_QUOTED
      ", voxel_info=" NS_FMT_POINTER
      ", file_name=" NS_FMT_STRING_DOUBLE_QUOTED
      ", flags=" NS_FMT_ULONG
      ", soma_ident=" NS_FMT_STRING_DOUBLE_QUOTED
      ", dend_ident=" NS_FMT_STRING_DOUBLE_QUOTED
      " )",
      ns_model_get_name( model ),
      voxel_info,
      file_name,
      flags,
      soma_ident,
      dend_ident
      );

	____ns_hoc_section_num_points = 0;

   section_type = ns_model_get_section_type( model );
 
	if( NS_FAILURE( ns_model_section( model, NS_MODEL_SPINES_SECTIONING, NULL ), error ) )
		return error;

	if( NS_FAILURE( ns_model_create_trees( model ), error ) )
		return error;
   
   error = /*( flags & NS_HOC_MULTIPLE_FILES ) ?
            _ns_hoc_write_multi_file(
					model,
					voxel_info,
					file_name,
					flags,
					soma_ident,
					dend_ident,
					invalid_sections_ident,
					unknown_sections_ident,
					soma_sections_ident,
					basal_dendrite_sections_ident,
					apical_dendrite_sections_ident,
					axon_sections_ident
					)
					:*/
            _ns_hoc_write_single_file(
					model,
					voxel_info,
					file_name,
					flags,
					soma_ident,
					dend_ident,
					invalid_sections_ident,
					unknown_sections_ident,
					soma_sections_ident,
					basal_dendrite_sections_ident,
					apical_dendrite_sections_ident,
					axon_sections_ident
					);

	if( ns_is_error( error ) )
		return error;

   /* Restore old sectionation if necessary. */
   if( section_type != NS_MODEL_SPINES_SECTIONING )
		if( NS_FAILURE( ns_model_section( model, section_type, NULL ), error ) )
			return error;

   return ns_no_error();
   }
